---
layout: post
title: k8s 学习杂记
---

pick central time == central coordinator
decentralized time = Truetime/HLC

Borg、Omega and Kubernetes

Borg manage long-running services and batch jobs
core a shared persistent store via API (k8s, applies higher-level versioning, validation, semantics, and policy, in support of a more diverse array of clients)

container:
the first container just isolation of root file system, jail of namespaces => cgroups
resource isolation gives better utilzation.
mordern container = isolation mechanism + image.
docker daemon and docker image registry.

application oriented infra
data center from machine to app-oriented.

ref: https://blog.devops.dev/kubernetes-complete-reference-badbc2ed9834

===
note from ma
最近的趋势是heterogenous HW
计算迭代很快，存贮比较慢。现在网络好，计算和存贮分离也可以接受

Data Center Topology
tor top of rack switch, L2 switch, 
multi-layer of router

管理数据中心的machine. 

screenshot of the cluster definalities

how is cluster management different?
HA
Scalable
Fault Tolerance
Distributed
Entities to manage

What's native service?
CNCF
Fault tolerance, Multi-tenancy, container based, namedspace, declare resource demand

Borg/Autopilot/Kubernetes


Pod Disruption Budget
Stateful info should be written to Spanner / BigTable etc.

Priority
check Borg.

Quota:
resource reservation
part of admission control

service discovery
Name


workload failure detection
liveness probe


=====
software can be cheap. business logic is tie 1 class.

当系统组件越来越小，新的从未需要思考的问题开始出现。从只有一台大机器部署所有东西，组件全在一个进程或者jvm里，不需要考虑patial failure的世界里走出来，你需要面对很多新的问题和挑战： 我的service，程序，应该部署在那里？我用的一个文件不小心和另外一个程序重名，而他们恰巧部署在一台机器怎么办？不小心把过多的东西部署在了一台机器上怎么办？一台不知道部署了什么的机器突然挂了怎么办？我service部署好了，我的其他组件怎么能找到它？把需要相互通信的机器的ip机器名都配置好了，突然要增加机器或者减少机器，或者更换机器怎么办？service正在服务我想要更新程序怎么办？我rollout了一个bug结果所有的node上的服务都挂了怎么办？…. 微服务的architecture比之前集中式的设计难上n多个档次，很多原先进程中的deterministic 同步方法调用，都将会被替换成跨service的远程调用。而分布式系统是non-deterministic的。这就好比给你一种cpu，它有99.99%的概率1+1返回2，而0.01%的概率1+1返回一个随机数. 在只有这种cpu的情况下，我需要你以100%的稳定性实现你原来的系统


我们发现在微服务环境中，有很多共有问题是可以统一解决的。它们包括：Service discovery: 让你的程序轻松获得任何其他组件的logical地址，即使这个组件真实的运行node换了100遍。Scaling up/down: 自动根据负载增加和减少机器，互联网公司最最基本需求Load balancing:负载均衡自动均衡到不同的机器Self healing: 组件由于任何原因(比如网断了，机器挂了)挂了都没问题，自动在另外的机器来启动。Leader electionSecurity 等而Container Orchestrators则提供了抽象和方便的工具来让程序员更简单和轻松的应对微服务构架下，我们遇到的各种难题。这就好比当多核成为趋势，多线程编程就成为程序员基本素质一样。而当我们的时代前进到这里, Container Orchestrators终将成为另外一种基础知识成为程序员的必备技能。所以即使你不喜欢Kubernetes，那么你也必然需要另一种类似的东西来解决Orchestration的问题；而解法都是类似的。


