---
layout: post
title: Linker and Loader
---




overview
---
```
Phase     Static                    Dynamic
--------  ----------------------    ------------------------
          +---------+               +---------+
          | main.c  |               | main.c  |
          +---------+               +---------+
Compile........|.........................|...................
          +---------+ +---------+   +---------+ +--------+
          | main.o  | | crt.a   |   | main.o  | | crt.h  |
          +---------+ +---------+   +---------+ +--------+
Link...........|..........|..............|...........|.......
               |          |              +-----------+
               |          |              |
          +---------+     |         +---------+ +--------+
          |  main   |-----+         |  main   | | crt.so |
          +---------+               +---------+ +--------+
Load/Run.......|.........................|..........|........
          +---------+               +---------+     |
          | main in |               | main in |-----+
          | memory  |               | memory  |
          +---------+               +---------+
```


tl;dr
static lib is part of the application.
dynamic lib is missing puzzle of the application loaded by OS.
plugin is lib with predefined interface, and are explicit loaded by application not OS

compiler side:

A definition of a variable induces the compiler to reserve some space for that variable, and possibly fill that space with a particular value.

A definition of a function induces the compiler to generate code for that function.

and declaration promise the compiler that this symbol is someplace else.

then we got a .o file with code and data(global variables)
the compiler leave a *blank* when see a declaration without implementation.


linker side:
*filling the blank*, relocate, make object files to a executable.

1. static link: the content of file are physically inserted into executable.(order of the events: cyclic dependency)
2. shared library(defer to dynamic link): it doesn't include in the final executable, but recored the name of the library, on run time, os pull the code of library and join all part before main function is run. (nm & ldd). this is why dll hell, loader re-link every time it runs. the crt.h is linked which delcared dynamic library but didn't define it. the implementation is loaded on run-time.
3. plugin: even more defer linking.(dlopen), it only bring in the dynamic linked file until invokation.

loader side:

1. load code/ text segment
2. bss to save space on disk


demo in action
===

1. gcc -c -fpic foo.c => foo.o
2. gcc -shared -o libfoo.so foo.o =>libfoo.so
3. gcc -Wall -o test main.c -lfoo => error, cannot find -lfoo
   *. gcc -o test main.c -L$PWD -lfoo => good
   *. gcc -o test main.c -I$PWD/include  -L$PWD/lib -lfoo => even better
4. run it => loader can't find shared libfoo.so because it is not in standard path (/usr/lib /lib)
   * LD_LIBRARY_PATH, and export it
   * rpath or runpath
   * ld.so.conf ldconfig ```ldconfig -p | grep foo```
5. -I for include, -L for library, -l for what you are looking for

===

Dynamic linking
---
the job of dynamic linker and loader(ld.so) is to resolve the executable's dependencies on shared libraries and to load the required ones at run-time.
readelf .bin to find the NEDDED headers and search the DSO with a matching SONAME

1. DT_RPATH in the ELF binary's NEEDDED library, unless DT_RUNPATH set.
2. DT_RPATH in the ELF binary, unless DT_RUNPATH set.
3. LD_LIBRARY_PATH entries, unless setuid/setgid
4. DT_RUNPATH in ELF binary
5. /etc/ld.so.cache entries, unless -z nodeflib given at link time
6. /lib, /usr/lib unless -z nodeflib
7. Done, "not found".

however, exceptions(small print...)

* step1 & 2 if DT_RPATH will ignored is DT_RUNPATH is set. then LD_LIBRARY_PATH will search first
* step 3 LD_LIBRARY can be override by calling dynamic linker with option --library-path
* step6 if executable is linked with ```-z`` so #6 is skipped.
* if using origin flag, remember to pass ```-z origin ``` to mark the obejct as requiring origin processing
* LD_PRELOAD happen before all those.
* ```LD_LIBRARY_PATH``` inherited by all processes generated by parent and it is considered evil


libtool:

libtool was made extensive use of RPATH feature, inlcuding hardcoded library path information by default executables and DSO. but now libtool no longer set rpath for any diretory for any directories in the dynamic linker search path.

fedora pathed libtool1.5 so that 64 bit linux platforms it search /lib64 /usr/lib64 + ld.so.conf


Encoding rpath/runpath in binaray
---
ELF binaries can contains supplemental path for DSO, those path must encoded at compile time and it is searched before system default path(which could overriden by LD_LIBRARY_PATH).
so the problem of find a DSO is done by the dev build the app rather than the user that deploy the app. there are two way to do rpath

1. set LD_RUN_PATH to the search path you want to encode
2. for rpath: add linker flag ```-R /usr/local/lib``` similar to -L, you could add multiple time, order doestn't matters AND ```--enable-new-dtags```for runpath
3. different compiler have different flag ```-Wl, -rpath, /user/local/lib```
4. using chrpath to change already-present RPATH

after compiler, you need to change elf binaray in order to change the rpath
```install_name_tool``` ir ```patchelf```

```
-Wl,-rpath='$ORIGIN' 
not -Wl,-z,origin 
not -Wl,-rpath,'\$\$ORIGIN'
```

tldr;

* rpath is NOT runpath, runpath is introduced around 2000 when rpath cause mass issue used by libtool via overriding LD_LIBRARY_PATH
* RUNPATH happens after LD_LIBRARY_PATH, and set RUNPATH will cancel RPATH.
* ```chrpath -d foo.so``` to suppress rpth => runpath.
* runpath is not used for finding indirect library dependecies.

###$ORIGIN
one of the common issue with explicit set the runpath is the use of absolute path. it is not a problem for fix system libraries, but you can't gurentee the lib will be searched on the same exactly path. this allow myapp to install anyway as long as they keep in same relative path. ```-Wl, -z origin```




System default path
---
command

1. ldconfig: updates the necessary links for the run time binding
2. ldd: tekk what's lib a given program needs to run
3. ltrace: A library call tracer
4. ld.so/ld-linux.so: dynamic linker/loader


important file

1. /lib/ld-linux.so.* : Execution time linker/loader.
2. /etc/ld.so.conf : File containing a list of colon, space, tab, newline, or comma separated directories in which to search for libraries.
3. /etc/ld.so.cache : File containing an ordered list of libraries found in the directories specified in /etc/ld.so.conf. This file is not in human readable format, and is not intended to be edited. This file is created by ldconfig command.
4. lib*.so.version : Shared libraries stores in /lib, /usr/lib, /usr/lib64, /lib64, /usr/local/lib directories.

supposed I installed a new library in~/lib then ```ldconfig -l ~/lib/foo.so``` to manually linking this DSO.

another way is to create a ```/etc/ld.so.conf/foo.conf``` (name don't matters). then ```ldconfig``` to update the cache.





chroot
---
put web server or build farm into a chroot. it is need to copy all files required insided rooted /jail/ directory, including bin, lib, modules and configuratation files. and also ```/etc/{ld.so.cache, ld.so.conf}```and ```/etc/ld.so.conf.d``` to ```/jail/etc/```


cp_support_shared_libs "/jail" "/usr/local/nginx/sbin/nginx"
[code example](https://gist.githubusercontent.com/longwei/a84dc48bbec21f297389/raw/f6f64991f3845c6f7191b7d428262dd0899bce94/gistfile1.txt)




ltrace
---
ltrace simply intercepts and records dynamic library calls and signals received. it could also intercept the system calls. it is the open write syscall that may have performace issue.

```ltrace -S -tt ./foo```

```
06:49:35.810781 SYS_brk(0)                       = 0x14db000
06:49:35.811163 SYS_access("/etc/ld.so.nohwcap", 00) = -2
06:49:35.811597 SYS_mmap(0, 8192, 3, 34)         = 0x7fefa706b000
06:49:35.811829 SYS_access("/etc/ld.so.preload", 04) = -2
06:49:35.812194 SYS_open("/etc/ld.so.cache", 524288, 01) = 3
06:49:35.812494 SYS_fstat(3, 0x7fff16d37cc0)     = 0
06:49:35.812604 SYS_mmap(0, 0x178e3, 1, 2)       = 0x7fefa7053000
06:49:35.812778 SYS_close(3)                     = 0
06:49:35.812911 SYS_access("/etc/ld.so.nohwcap", 00) = -2
06:49:35.813185 SYS_open("/lib/x86_64-linux-gnu/libc.so.6", 524288, 024701570710) = 3
06:49:35.813620 SYS_read(3, "\177ELF\002\001\001", 832) = 832
06:49:35.813809 SYS_fstat(3, 0x7fff16d37d10)     = 0
06:49:35.813924 SYS_mmap(0, 0x3c52c0, 5, 2050)   = 0x7fefa6a85000
06:49:35.814122 SYS_mprotect(0x7fefa6c41000, 2093056, 0) = 0
06:49:35.814266 SYS_mmap(0x7fefa6e40000, 0x6000, 3, 2066) = 0x7fefa6e40000
06:49:35.814439 SYS_mmap(0x7fefa6e46000, 0x42c0, 3, 50) = 0x7fefa6e46000
06:49:35.814624 SYS_close(3)                     = 0
06:49:35.814755 SYS_mmap(0, 4096, 3, 34)         = 0x7fefa7052000
06:49:35.814935 SYS_mmap(0, 8192, 3, 34)         = 0x7fefa7050000
06:49:35.815115 SYS_arch_prctl(4098, 0x7fefa7050740, 0x7fefa7051050, 34) = 0
06:49:35.815367 SYS_mprotect(0x7fefa6e40000, 16384, 1) = 0
06:49:35.815626 SYS_mprotect(0x600000, 4096, 1)  = 0
06:49:35.815782 SYS_mprotect(0x7fefa706d000, 4096, 1) = 0
06:49:35.815916 SYS_munmap(0x7fefa7053000, 96483) = 0
06:49:35.817359 __libc_start_main(0x40052d, 1, 0x7fff16d38698, 0x400550 <unfinished ...>
06:49:35.817764 puts("Hello world" <unfinished ...>
06:49:35.818278 SYS_fstat(1, 0x7fff16d38460)     = 0
06:49:35.818538 SYS_mmap(0, 4096, 3, 34)         = 0x7fefa706a000
06:49:35.818866 SYS_write(1, "Hello world\n", 12Hello world
) = 12
06:49:35.819178 <... puts resumed> )             = 12
06:49:35.819332 SYS_exit_group(0 <no return ...>
06:49:35.819501 +++ exited (status 0) +++

```

or ``` ltrace -e malloc,free ./foo``` ```ltrace -e fopen,fread,fwrite,fclose ./foo```


Implications for installation and invocation
---
In brief, the implications include these alternatives:

* Put new .so’s in directories where the ld-linux already looks, such as /usr/lib (ie: InstallDir equals /usr). Or…
* Add configuration information for ld-config so that it looks in new directories that your installation has added. Or…
* Have users launch programs that need your .so’s using a script that augments the LD_LIBRARY_PATH environment variable to tell ld-config additional places to look. (pretty saft as it will not impact other process)
* The developers could include instructions into the executable (possible settable using configure during install) as to where to tell ld-linux to find libraries.

Note that if the new package includes .so’s just for its own use only, it will still need ld to load those .so’s, and thus need to use one of the methods to tell ld where to find them.




linker and sonames
---

in debian's convention, run-time(libfoo1: /usr/lib/libfoo.so.1-> libfoo.so.1.0.0) or dev (libfoo-dev: /usr/lib/libfoo.so->libfoo.so.1.0.0)

first of all there are several different name fo a shared library:

* the actual name of the file
* the name for build-time linker(ld)
* the name for dynamic linker(ld.so)

so we got symbolic links

when build-time linking, the ld take either ```/usr/lib/libfoo.so.0.0.1``` or via ```-foo```, the path where the linker search for this libfoo is discussed above.

when build-time linker add this libfoo.so to the output, it need to name it.
that's SONAME. the linker will DT_SONAME and DT_NEEDED entry tag of the output file. but the loader only care about DT_NEEDED.

as a result, the DSO loader find don't have to be the same one as build-time linker). the linker will load it anyway, but fail in a subtle ways.

to ensure the loader is able to find the library, ```libtool``` works at build-time and install-time, to make both symbolic link used by loader and dynamic linker.


the second half is ldconfig, which recreate all symlinks to sonames in library search path

[ref](https://blog.flameeyes.eu/2010/10/linkers-and-names#gsc.tab=0)










