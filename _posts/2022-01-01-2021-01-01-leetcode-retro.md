---
layout: post
title: leetcode 01-01 retro
---

## 973. K Closest Points to Origin

1. the top k problem then we have pq, the difficult part is to write custom pq declaration/sorter
2. we need top k, but not top k sorted, so we could use quick select to partition the array into smaller than k, and bigger than k. 

```cpp
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        auto sortByDis = [](const auto& p1, const auto& p2){
            int d1 = p1[0] * p1[0] + p1[1] * p1[1];
            int d2 = p2[0] * p2[0] + p2[1] * p2[1];
            return d1 > d2;
        };
        
        priority_queue<vector<int>, vector<vector<int>>, 
                       decltype(sortByDis)> pq(points.begin(), points.end(), sortByDis);
        // for (auto& p: points) {
        //     pq.push(p);
        // }
        vector<vector<int>> ans;
        while (k--) {
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }
    
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        auto sortByDis = [](const auto& p1, const auto& p2){
            int d1 = p1[0] * p1[0] + p1[1] * p1[1];
            int d2 = p2[0] * p2[0] + p2[1] * p2[1];
            return d1 < d2;
        };
        //n_th element is the quick select
        nth_element(points.begin(), points.begin() + k, points.end(), sortByDis);
        return vector<vector<int>>(points.begin(), points.begin() + k);
    }
};
```

## 476. Number Complement
1. xor will flip a bit, so we could xor each bit using right shift `>>` and left shift `<<`
2. how about construct a 111 bitmask and do the xor in one shot? log(x)/log2 + 1, then `(1 << n) - 1` 
3. highestOneBit from hacker's delight. same 1 bit bitmask from 1->2->4->8->16 for 32 bit integer.


```cpp
class Solution {
public:
    int findComplement(int num) {
        int todo  = num, bit = 1;
        while (todo != 0) {
            num = num ^ bit;
            bit = bit << 1;
            todo = todo >> 1;
        }
        return num;
    }
};

class Solution {
public:
    int findComplement(int num) {
    // n is a length of num in binary representation
    int n = (int)( Math.log(num) / Math.log(2) ) + 1;
    // bitmask has the same length as num and contains only ones 1...1
    int bitmask = (1 << n) - 1;
    // flip all bits
    return bitmask ^ num;
  }
}

class Solution {
public:
    int findComplement(int num) {
    // bitmask has the same length as num and contains only ones 1...1
    int bitmask = num;
    bitmask |= (bitmask >> 1);
    bitmask |= (bitmask >> 2);
    bitmask |= (bitmask >> 4);
    bitmask |= (bitmask >> 8);
    bitmask |= (bitmask >> 16);
    // flip all bits 
    return bitmask ^ num;
  }
}

```

## 876. Middle of the Linked List

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```
## 116. Populating Next Right Pointers in Each Node

1. most straight forward is level bfs
2. follow up, how to do it in constant time, then it must be recursive
3. 只有一个点是不能做到的，必须一次看三个点
4. 一个办法是一次进两个， postorder左右之后在连起来， 好处是order随意
5. 只用一个也可以，但是得是postorder

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        if (!root) return root;
        queue<Node*> q;
        q.push(root);
        while (!q.empty()) {
            int size = q.size();
            while (size--){
                Node* cur = q.front(); q.pop();
                cur->next = (size > 0) ? q.front(): nullptr;
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
        }
        return root;
    }
};
    
class Solution {
public:
    Node* connect(Node* root) {
        if (!root) return nullptr;
        connect(root->left, root->right);
        return root;
    }
    
    void connect(Node* left, Node* right){
        if (!left || !right) {
            return;
        }
        //order don't matter
        //o(2n)  7node=>13
        left->next = right;
        connect(left->left, left->right);
        connect(right->left, right->right);
        connect(left->right, right->left);
    }
};

class Solution {
public:
  Node* connect(Node* root) {
    if (!root || !root->left) return root;
    
    if (root->next)
      root->right->next = root->next->left;
    root->left->next = root->right;
       
    connect(root->right);
    connect(root->left);
   
    return root;
  }
};
```
